# AutoBattler RPG (Qt + C++)

**AutoBattler RPG** — это проект на **C++/Qt**, в котором игрок сражается с монстрами в автоматических боях.  
Игрок выбирает начальный класс, улучшает уровни, получает дроп, и стремится выиграть 5 боёв подряд.

---

##  Возможности

- **Пошаговая система боя** (автоматическая симуляция с логом в UI)
- **Система классов (Warrior, Rogue, Barbarian)** с уникальными эффектами:
  - **Воин** — сильная защита и бонус в первый ход  
  - **Разбойник** — скрытая атака и яд  
  - **Варвар** — ярость и бонус от выносливости
- **Контекст боя (`BattleContext`)** — хранит данные о текущем ходе, уроне и логах
- **Рост уровней и классов**
  - После победы — выбор, какой класс повысить
- **Система оружия и дропа**
  - Побеждённый монстр может уронить оружие
  - Игрок выбирает — подобрать или пропустить
- **Условие победы** — выиграй 5 боёв, чтобы завершить игру

---
## Геймплей

1. **Выбери класс** (Воин, Разбойник или Варвар) на экране `MainWindow`
2. **Нажми “Start”**, чтобы начать первый бой
3. **Следи за логом боя** в `BattleWindow`
4. После победы:
   - Выбери, **брать ли дроп**
   - Выбери, **какой класс повысить**
5. После 5 побед игра завершается

---

## Архитектура

| Класс / Файл | Ответственность |
|---------------|----------------|
| `Game` | Управляет состоянием игры, победами, вызовом боёв |
| `Battle` | Проводит бой между `Player` и `Monster` |
| `BattleWorker` | Выполняет бой в отдельном потоке и отправляет сигналы в UI |
| `Player` | Игрок с мультикласс-системой |
| `Monster` | Противник с характеристиками и трейтами |
| `CharacterClassBase` | Базовый интерфейс классов (реализуется: Warrior, Rogue, Barbarian) |
| `BattleWindow` | Интерфейс боя: HP бары, логи, кнопки |
| `MainWindow` | Экран выбора персонажа |
| `Weapon` | Базовый класс оружия и фабрика `createWeapon()` |

---

### Архитектурный подход

Проект построен по принципам **объектно-ориентированного дизайна (ООП)** и **чистой архитектуры (Clean Architecture)**:
- Логика игры полностью отделена от интерфейса.
- Класс `Game` управляет состоянием и бизнес-логикой.
- `BattleWindow` и `MainWindow` отвечают только за отображение и взаимодействие с пользователем (UI-слой).
- Потоки (`BattleWorker` и `QThread`) разгружают UI, обеспечивая плавную анимацию логов боя.

Такое разделение обеспечивает:
- **тестируемость** (логику можно тестировать отдельно от интерфейса),
- **расширяемость** (новые классы, оружие и эффекты можно добавлять без переписывания старого кода),
- **надёжность** (UI не зависает во время боя).

---

## Используемые паттерны проектирования

### 1. **Factory Method **  
Используется в функции `createWeapon(name)` для создания объектов `Weapon` по строковому имени.

### 2. Strategy

Каждый класс (`WarriorClass`, `RogueClass`, `BarbarianClass`) реализует собственную стратегию поведения в бою через методы `onAttack()` и `onDefense()`.
Поведение боя меняется **в зависимости от активного класса**, но интерфейс (`CharacterClassBase`) остаётся единым.

### 3. Dependency Injection

Паттерн используется для того, чтобы классы не создавали свои зависимости самостоятельно,  
а получали их "извне" — через параметры или конструкторы.  

В проекте это видно на примере класса `Battle`:  
он не создаёт внутри себя `Player` или `Monster`,  
а получает их через аргументы метода `run()`.

### 4. MVVM

Проект построен по архитектурному паттерну **MVVM**, который отделяет **логику данных**,  
**представление (UI)** и **связующее звено (ViewModel)** для удобного расширения и поддержки кода.

### 5. SOLID

Проект следует основным принципам **SOLID**, что делает архитектуру гибкой, устойчивой к изменениям  
и легко расширяемой без нарушения существующего кода.

- Каждый класс выполняет **только одну логическую задачу**
- Классы **открыты для расширения, но закрыты для модификации**
- Любой подкласс может **заменять базовый** без изменения логики
- Интерфейсы не перегружены и содержат **только нужные методы**
- Классы зависят от абстракций, а не от конкретных реализаций
